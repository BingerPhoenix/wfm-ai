/**
 * Data Loading Layer for WFM.ai Synthetic Data
 *
 * Provides functions to load, parse, and extract insights from
 * the synthetic contact center dataset generated by Python scripts.
 */

// Types for synthetic data structures
export interface SyntheticSummary {
  totalContacts: number;
  avgWeeklyVolume: number;
  peakDay: { date: string; volume: number };
  lowestDay: { date: string; volume: number };
  deflectionImprovement: string;
  avgSLA: number;
  slaVariance: number;
  contactMix: { calls: string; chats: string; emails: string };
  keyMetrics: {
    totalFTEs: number;
    avgHandleTime: number;
    annualAgentCost: number;
    deflectionSavings: number;
  };
  dataQuality: {
    recordCount: number;
    dateRange: string;
    anomaliesIncluded: string[];
  };
}

export interface VolumeRecord {
  date: string;
  hour: number;
  calls: number;
  chats: number;
  emails: number;
  contactType: {
    billing: number;
    technical: number;
    general: number;
    sales: number;
  };
}

export interface DeflectionRecord {
  month: string;
  overallRate: number;
  byType: {
    billing: number;
    technical: number;
    general: number;
    sales: number;
  };
  botUpdates: string | null;
}

export interface StaffingRecord {
  date: string;
  shift: 'morning' | 'midday' | 'evening';
  scheduled: number;
  actual: number;
  ptoCount: number;
  sickCount: number;
  trainingCount: number;
}

export interface SLARecord {
  date: string;
  target: number;
  actual: number;
  avgWaitTime: number;
  abandonment: number;
}

export interface CostData {
  agentCosts: {
    average: number;
    range: { min: number; max: number };
    byTenure: Array<{ years: string; avgSalary: number; count: number }>;
    benefits: number;
    overtimeRate: number;
  };
  aiCosts: {
    perContact: number;
    monthlyTrend: Array<{ month: string; perContact: number; totalCost: number }>;
    infrastructure: number;
    trainingCostPerAgent: number;
  };
  benchmarks: {
    byIndustry: Record<string, { deflectionRate: number; avgSLA: number; agentCost: number }>;
    byRegion: Record<string, { agentCost: number; benefits: number }>;
    handleTime: { industry: number; ourCenter: number; target: number };
  };
  projections: {
    deflectionGrowth: number;
    costPerAgent: number;
    potentialSavings: Record<string, { agentReduction: number; annualSavings: number }>;
  };
}

// Cache for loaded data
let dataCache: {
  summary?: SyntheticSummary;
  volume?: VolumeRecord[];
  deflection?: DeflectionRecord[];
  staffing?: StaffingRecord[];
  sla?: SLARecord[];
  costs?: CostData;
  lastLoaded?: number;
} = {};

const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Data loading functions
export class SyntheticDataLoader {
  private static async fetchJson<T>(filename: string): Promise<T> {
    try {
      const response = await fetch(`/data/${filename}`);
      if (!response.ok) {
        throw new Error(`Failed to load ${filename}: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      console.warn(`Failed to load ${filename}, using fallback data:`, error);
      return {} as T;
    }
  }

  private static isCacheValid(): boolean {
    return dataCache.lastLoaded &&
           (Date.now() - dataCache.lastLoaded) < CACHE_DURATION;
  }

  /**
   * Load summary statistics
   */
  static async loadSummary(): Promise<SyntheticSummary> {
    if (this.isCacheValid() && dataCache.summary) {
      return dataCache.summary;
    }

    const summary = await this.fetchJson<SyntheticSummary>('summary_stats.json');
    dataCache.summary = summary;
    dataCache.lastLoaded = Date.now();
    return summary;
  }

  /**
   * Load historical volume data
   */
  static async loadVolumeData(dateRange?: { start?: string; end?: string }): Promise<VolumeRecord[]> {
    if (this.isCacheValid() && dataCache.volume) {
      return this.filterByDateRange(dataCache.volume, dateRange);
    }

    const volume = await this.fetchJson<VolumeRecord[]>('historical_volume.json');
    dataCache.volume = volume;
    dataCache.lastLoaded = Date.now();
    return this.filterByDateRange(volume, dateRange);
  }

  /**
   * Load deflection history
   */
  static async loadDeflectionHistory(): Promise<DeflectionRecord[]> {
    if (this.isCacheValid() && dataCache.deflection) {
      return dataCache.deflection;
    }

    const deflection = await this.fetchJson<DeflectionRecord[]>('deflection_history.json');
    dataCache.deflection = deflection;
    dataCache.lastLoaded = Date.now();
    return deflection;
  }

  /**
   * Load staffing data
   */
  static async loadStaffingData(dateRange?: { start?: string; end?: string }): Promise<StaffingRecord[]> {
    if (this.isCacheValid() && dataCache.staffing) {
      return this.filterByDateRange(dataCache.staffing, dateRange);
    }

    const staffing = await this.fetchJson<StaffingRecord[]>('staffing_schedules.json');
    dataCache.staffing = staffing;
    dataCache.lastLoaded = Date.now();
    return this.filterByDateRange(staffing, dateRange);
  }

  /**
   * Load SLA performance data
   */
  static async loadSLAData(dateRange?: { start?: string; end?: string }): Promise<SLARecord[]> {
    if (this.isCacheValid() && dataCache.sla) {
      return this.filterByDateRange(dataCache.sla, dateRange);
    }

    const sla = await this.fetchJson<SLARecord[]>('sla_performance.json');
    dataCache.sla = sla;
    dataCache.lastLoaded = Date.now();
    return this.filterByDateRange(sla, dateRange);
  }

  /**
   * Load cost and benchmark data
   */
  static async loadCostData(): Promise<CostData> {
    if (this.isCacheValid() && dataCache.costs) {
      return dataCache.costs;
    }

    const costs = await this.fetchJson<CostData>('cost_data.json');
    dataCache.costs = costs;
    dataCache.lastLoaded = Date.now();
    return costs;
  }

  /**
   * Helper function to filter data by date range
   */
  private static filterByDateRange<T extends { date: string }>(
    data: T[],
    dateRange?: { start?: string; end?: string }
  ): T[] {
    if (!dateRange?.start && !dateRange?.end) {
      return data;
    }

    return data.filter(record => {
      const recordDate = new Date(record.date);
      const startDate = dateRange.start ? new Date(dateRange.start) : new Date('1900-01-01');
      const endDate = dateRange.end ? new Date(dateRange.end) : new Date('2100-01-01');

      return recordDate >= startDate && recordDate <= endDate;
    });
  }

  /**
   * Clear cache (useful for testing or forced refresh)
   */
  static clearCache(): void {
    dataCache = {};
  }
}

// Query-specific data extractors
export class DataExtractors {
  /**
   * Get daily volume totals for a specific date range
   */
  static async getDailyVolumes(dateRange?: { start?: string; end?: string }): Promise<Array<{
    date: string;
    totalVolume: number;
    calls: number;
    chats: number;
    emails: number;
    byType: { billing: number; technical: number; general: number; sales: number };
  }>> {
    const volumeData = await SyntheticDataLoader.loadVolumeData(dateRange);

    const dailyTotals = volumeData.reduce((acc, record) => {
      if (!acc[record.date]) {
        acc[record.date] = {
          date: record.date,
          totalVolume: 0,
          calls: 0,
          chats: 0,
          emails: 0,
          byType: { billing: 0, technical: 0, general: 0, sales: 0 }
        };
      }

      acc[record.date].totalVolume += record.calls + record.chats + record.emails;
      acc[record.date].calls += record.calls;
      acc[record.date].chats += record.chats;
      acc[record.date].emails += record.emails;
      acc[record.date].byType.billing += record.contactType.billing;
      acc[record.date].byType.technical += record.contactType.technical;
      acc[record.date].byType.general += record.contactType.general;
      acc[record.date].byType.sales += record.contactType.sales;

      return acc;
    }, {} as Record<string, any>);

    return Object.values(dailyTotals).sort((a, b) => a.date.localeCompare(b.date));
  }

  /**
   * Get hourly patterns for a specific date
   */
  static async getHourlyPattern(date: string): Promise<VolumeRecord[]> {
    const volumeData = await SyntheticDataLoader.loadVolumeData({ start: date, end: date });
    return volumeData.sort((a, b) => a.hour - b.hour);
  }

  /**
   * Get staffing vs. demand analysis for charts
   */
  static async getStaffingAnalysis(date: string): Promise<Array<{
    hour: string;
    demand: number;
    scheduled: number;
    actual: number;
    gap: number;
  }>> {
    const [volumeData, staffingData] = await Promise.all([
      this.getHourlyPattern(date),
      SyntheticDataLoader.loadStaffingData({ start: date, end: date })
    ]);

    // Group staffing by shift times
    const shiftMap = {
      morning: { start: 8, end: 12 },
      midday: { start: 12, end: 17 },
      evening: { start: 17, end: 21 }
    };

    const staffingByHour = volumeData.map(volume => {
      const hour = volume.hour;

      // Find which shift this hour belongs to
      let shiftStaffing = { scheduled: 0, actual: 0 };
      for (const [shift, times] of Object.entries(shiftMap)) {
        if (hour >= times.start && hour < times.end) {
          const shiftData = staffingData.find(s => s.shift === shift);
          if (shiftData) {
            shiftStaffing = { scheduled: shiftData.scheduled, actual: shiftData.actual };
          }
          break;
        }
      }

      const demand = Math.ceil((volume.calls + volume.chats + volume.emails) / 8); // Contacts per agent per hour
      const gap = shiftStaffing.actual - demand;

      return {
        hour: `${hour.toString().padStart(2, '0')}:00`,
        demand,
        scheduled: shiftStaffing.scheduled,
        actual: shiftStaffing.actual,
        gap
      };
    });

    return staffingByHour;
  }

  /**
   * Get anomaly events for highlighting on charts
   */
  static async getAnomalies(): Promise<Array<{
    date: string;
    type: 'outage' | 'viral' | 'campaign' | 'bot_failure';
    description: string;
    impact: 'high' | 'medium' | 'low';
  }>> {
    return [
      {
        date: '2024-03-15',
        type: 'outage',
        description: 'System outage caused 2x volume next day',
        impact: 'high'
      },
      {
        date: '2024-06-03',
        type: 'viral',
        description: 'Social media viral incident (3x volume)',
        impact: 'high'
      },
      {
        date: '2024-09-01',
        type: 'campaign',
        description: 'Product launch campaign (+40% volume)',
        impact: 'medium'
      },
      {
        date: '2024-10-10',
        type: 'bot_failure',
        description: 'Bot failure (deflection dropped to 5%)',
        impact: 'medium'
      }
    ];
  }

  /**
   * Get trend analysis for deflection improvements
   */
  static async getDeflectionTrends(): Promise<Array<{
    month: string;
    overallRate: number;
    improvement: number;
    milestone?: string;
  }>> {
    const deflectionData = await SyntheticDataLoader.loadDeflectionHistory();

    return deflectionData.map((record, index) => {
      const prevRate = index > 0 ? deflectionData[index - 1].overallRate : record.overallRate;
      const improvement = ((record.overallRate - prevRate) / prevRate) * 100;

      return {
        month: record.month,
        overallRate: record.overallRate,
        improvement: index === 0 ? 0 : improvement,
        milestone: record.botUpdates || undefined
      };
    });
  }
}

// Summary statistics generator
export class StatisticsGenerator {
  /**
   * Generate real-time insights for dashboard
   */
  static async generateInsights(): Promise<{
    totalContacts: number;
    avgDailyVolume: number;
    deflectionRate: number;
    slaPerformance: number;
    costSavings: number;
    peakHour: string;
    trends: {
      volumeTrend: 'up' | 'down' | 'stable';
      deflectionTrend: 'improving' | 'declining' | 'stable';
      slaTrend: 'improving' | 'declining' | 'stable';
    };
  }> {
    const [summary, deflection, sla] = await Promise.all([
      SyntheticDataLoader.loadSummary(),
      SyntheticDataLoader.loadDeflectionHistory(),
      SyntheticDataLoader.loadSLAData()
    ]);

    // Calculate recent trends (last 3 months vs previous 3 months)
    const recentDeflection = deflection.slice(-3);
    const previousDeflection = deflection.slice(-6, -3);

    const recentSLA = sla.slice(-90); // Last 90 days
    const previousSLA = sla.slice(-180, -90);

    const avgRecentDeflection = recentDeflection.reduce((sum, d) => sum + d.overallRate, 0) / recentDeflection.length;
    const avgPreviousDeflection = previousDeflection.reduce((sum, d) => sum + d.overallRate, 0) / previousDeflection.length;

    const avgRecentSLA = recentSLA.reduce((sum, s) => sum + s.actual, 0) / recentSLA.length;
    const avgPreviousSLA = previousSLA.reduce((sum, s) => sum + s.actual, 0) / previousSLA.length;

    return {
      totalContacts: summary.totalContacts || 0,
      avgDailyVolume: Math.round((summary.avgWeeklyVolume || 0) / 7),
      deflectionRate: avgRecentDeflection,
      slaPerformance: avgRecentSLA,
      costSavings: summary.keyMetrics?.deflectionSavings || 0,
      peakHour: '10:00', // Based on known patterns
      trends: {
        volumeTrend: 'stable', // Could be calculated from recent volume data
        deflectionTrend: avgRecentDeflection > avgPreviousDeflection ? 'improving' : 'declining',
        slaTrend: avgRecentSLA > avgPreviousSLA ? 'improving' : 'declining'
      }
    };
  }
}

export default SyntheticDataLoader;